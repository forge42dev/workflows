#!/usr/bin/env bash
echo "HELLO I AM IN PREPARE VARS"

shopt -s globstar

# if [[ -z "$LOCAL_DEV" ]]; then local_dev=false; else local_dev=true; fi
# v () { if $local_dev; then echo "$1"; else echo "$2"; fi; }
group () { echo "::group::$1"; }
end_group () { echo "::endgroup::"; }
debug () { echo "::debug::$1"; }
notice () { echo "::notice::$1"; }
warning () { echo "::warning::$1"; }

function prepare_vars () {
  group "Prepare variables needed for deployment"
  # The function expects a json string as input, e.g. '{"foo": "bar", "hello": "world"}'.
  # It will set the local variables with the same name as the json keys, e.g. 'local input_foo="bar"'
  # This allows you to process the 'input_*' variables first, then set them in the global scope of the script.
  local input_vars=$(echo "$1" | jq -r 'to_entries | map("local input_\(.key)=\(.value|@sh)") | .[]')
  eval "$input_vars"

  # We dont set local variables here, because we want to be able to use them in the rest of the script
  workspace_name=${input_workspace_name:-}

  if [[ -z "$workspace_name" ]]; then
    debug "workspace_name not set, using current directory"
    workspace_path="."
    workspace_name="$(jq -rS '.name' package.json)"
  else
    workspace_path="$(grep -rls "\"name\":.*\"$workspace_name\"" **/package.json | xargs -I {} dirname {})"
  fi

  debug "workspace_name=$workspace_name"
  debug "workspace_path=$workspace_path"

  end_group
}

prepare_vars "{\"workspace_name\": \"${WORKSPACE_NAME:-}\"}"

echo "workspace_path=$workspace_path"
echo "workspace_name=$workspace_name"

# if [[ -z "${{ inputs.workspace_name }}" ]]; then
#   # workspace name not set --> use the current directory
#   workspace_path="./"
# else
#   workspace_path="$(grep -rls '"name":.*"${{ inputs.workspace_name }}"' **/package.json | xargs -I {} dirname {})"
# fi

# # if [ -z "${{ inputs.app_name }}" ]; then
# #   app_name="${{ github.repository }}"
# #   # If the app name is not set, the absolute path of the workspace is the current directory
# #   #workspace_path="./"
# #   #absolute_workspace_path="$(dirname "$(pwd)/$workspace_path")"
# # else
# #   app_name="${{ inputs.app_name }}"
# #   # Get the absolute path of the workspace.
# #   # e.g. '/path/to/monorepo/apps/external/the-workspace'
# #   #workspace_path="$(grep -rls '"name":.*"${{ inputs.app_name }}"' **/package.json | xargs -I {} dirname {})"
# #   #absolute_workspace_path="$(pwd)/$workspace_path"
# #   # If no workspace is found, exit with an error
# #   #if [ -z "$workspace_path" ]; then
# #   #  echo "::error::No workspace with name '${{ inputs.app_name }}' found.";
# #   #  exit 1;
# #   #fi
# # fi

# app_name="${{ inputs.app_name }}"
# echo "::notice::app_name=$app_name"
# echo "app_name=$app_name" >> $GITHUB_OUTPUT

# fly_config_file_path="${{ inputs.fly_config_file_path }}"
# echo "::notice::fly_config_file_path=$fly_config_file_path"

# #echo "::notice::absolute_workspace_path=$absolute_workspace_path"

# #echo "::notice::workspace_path=$workspace_path"
# #echo "workspace_path=$workspace_path" >> $GITHUB_OUTPUT


# if [ "${{ github.event_name }}" == "pull_request" ]; then
#   git_sha="$(git rev-parse --short ${{github.event.pull_request.head.sha}})"
# else
#   git_sha="$(git rev-parse --short $GITHUB_SHA)"
# fi

# echo "::notice::git_sha=$git_sha"
# echo "git_sha=$git_sha" >> $GITHUB_OUTPUT

# # Get the app name, replaces '/' and '.' with '-', everything else gets removed to make it url friendly
# # e.g. 'octo-CAT/monorepo-stack_@some_WORKSPACE?foo=bar' => 'octo-cat-monorepo-stack-some-workspacefoobar'
# app_normalized_name="$(echo $app_name | sed 's/[\.\/_]/-/g; s/[^a-zA-Z0-9-]//g' | tr '[:upper:]' '[:lower:]')"

# # Set the app name as an github output
# echo "::notice::app_normalized_name=$app_normalized_name"
# echo "app_normalized_name=$app_normalized_name" >> $GITHUB_OUTPUT
